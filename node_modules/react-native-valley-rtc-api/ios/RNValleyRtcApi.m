
#import "RNValleyRtcApi.h"
#include <ifaddrs.h>
#include <arpa/inet.h>
#include <ValleyRtcAPI/ValleyRtcAPI_OC.h>

@implementation RNValleyRtcApi
{
    BOOL haveListener;
    NSTimer *timer;
}

- (dispatch_queue_t)methodQueue
{
    return dispatch_get_main_queue();
}

+ (BOOL)requiresMainQueueSetup {
    return YES;
}

RCT_EXPORT_MODULE()

RCT_EXPORT_METHOD(addEvent:(NSString*)name location:(NSString*)location) {
    RCTLogInfo(@"=======  addEvent,  Pretending to create an event %@ at %@", name, location);
}

RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback) {
    RCTLogInfo(@"=======  findEvents");
    NSArray *events = [NSArray arrayWithObjects:@"abc", nil];
    callback(@[[NSNull null], events]);
}

RCT_EXPORT_METHOD(getIpAddress:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    RCTLogInfo(@"=======  getIpAddress");
    NSString *address = @"0.0.0.0";
    struct ifaddrs *interfaces = NULL;
    struct ifaddrs *temp_addr = NULL;
    int success = 0;
    // retrieve the current interfaces - returns 0 on success
    success = getifaddrs(&interfaces);
    if (success == 0) {
        // Loop through linked list of interfaces
        temp_addr = interfaces;
        while(temp_addr != NULL) {
            if(temp_addr->ifa_addr->sa_family == AF_INET) {
                // Check if interface is en0 which is the wifi connection on the iPhone
                if([[NSString stringWithUTF8String:temp_addr->ifa_name] isEqualToString:@"en0"]) {
                    // Get NSString from C String
                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr)];
                }
            }
            temp_addr = temp_addr->ifa_next;
        }
    }
    // Free memory
    freeifaddrs(interfaces);
    resolve(address);
}

- (NSArray<NSString *> *)supportedEvents
{
    RCTLogInfo(@"=======  supportedEvents");
    return @[@"geolocationDidChange", @"geolocationError"];
}

-(void) onTimer:(NSTimer*)sender {
    if (haveListener) {
        [self sendEventWithName:@"geolocationDidChange" body:@{@"name":@"123213"}];
    }
}

- (void)startObserving {
    RCTLogInfo(@"=======  startObserving");
    haveListener = YES;
    if (!timer) {
//        timer = [ NSTimer  scheduledTimerWithTimeInterval: 0.5
//                                               target: self
//                                             selector: @selector(onTimer:)
//                                             userInfo:nil
//                                              repeats: YES ];
    }
}

- (void)stopObserving {
    RCTLogInfo(@"=======  stopObserving");
    haveListener = NO;
    if (timer) {
        [timer invalidate];
        timer = nil;
    }
}

#pragma mark -- valley api


#pragma mark -- valley function return result

- (NSDictionary*)constantsToExport {
    RCTLogInfo(@"=======  constantsToExport");
    return @{@"ERR_SUCCEED":@(ERR_SUCCEED),
             @"ERR_NOT_LOGINED":@(ERR_NOT_LOGINED),
             @"ERR_ALREADY_RUN":@(ERR_ALREADY_RUN),
             @"ERR_USER_NOTFOUND":@(ERR_USER_NOTFOUND),
             @"ERR_EXCUTING":@(ERR_EXCUTING),
             @"ERR_NOT_INITIALIZE":@(ERR_NOT_INITIALIZE),
             @"ERR_UNSUPPORT":@(ERR_UNSUPPORT),
             @"ERR_ARGUMENT":@(ERR_ARGUMENT),
             @"ERR_CHANNEL_EXPIRED":@(ERR_CHANNEL_EXPIRED),
             @"ERR_CONNECT_SERVER_FAILED":@(ERR_CONNECT_SERVER_FAILED),
             @"ERR_REQUEST_TIMEOUT":@(ERR_REQUEST_TIMEOUT),
             @"ERR_CONFIG":@(ERR_CONFIG),
             @"ERR_NET_POOL":@(ERR_NET_POOL),
             @"ERR_VERSION_UNSUPPORTED":@(ERR_VERSION_UNSUPPORTED),
             @"ERR_AUTHO_FAILED":@(ERR_AUTHO_FAILED),
             @"ERR_NOT_ENOUGH_CHANNEL":@(ERR_NOT_ENOUGH_CHANNEL),
             @"ERR_SERVER_ERROR":@(ERR_SERVER_ERROR),
             @"ERR_OPEN_RECORD":@(ERR_OPEN_RECORD),
             @"ERR_OPEN_PLAYOUT":@(ERR_OPEN_PLAYOUT),
             @"ERR_RECORD_PERMISSION":@(ERR_RECORD_PERMISSION),
             
             @"ERR_OPEN_RECORD":@(ERR_OPEN_RECORD),
             };
}

@end
  
